- 학습 내용 : 자료 구조와 알고리즘
- 최종 목표 : 연습 문제가 아닌 ‘**현실 세계 문제**’

## [ 알고리즘 ]

- 알고리즘 : **문제를 해결하기 위한 절차나 방법**
- 좋은 알고리즘 : 정확성, 작업량, 메모리 사용량, 단순성, 최적성

< 알고리즘을 표현하는 방법 >

1. 의사코드(슈도코드) : 모델링용, 흉내만 내는 코드, 컴퓨터에서 실행할 수 없음
2. 순서도(흐름도) : 프로그램의 진행 흐름을 나타낸 도표 

예) 1부터 100까지 합을 구하는 문제

알고리즘 1 : 1+2+…+100 = 5050

알고리즘 2 : 100 x (1+100) / 2 = 5050

- 시간복잡도 (알고리즘의 작업량을 표현할 때)
    - 실제 걸리는 시간을 측정
    - 실행되는 명령문의 개수 계산

- 시간복잡도 : **빅-오 표기법**
    - 시간 복잡도 함수 중에서 가장 큰 영향력을 주는  n에 대한 항만을 표시
    - 계수는 생략

예) O(3n+2) = O(3n) 최고차항 추출 = O(n) 계수 생략

- n개의 데이터를 입력 받아 저장한 후 각 데이터에 1씩 증가시킨 후 각 데이터를 화면에 출력하는 알고리즘의 시간복잡도? O(n)

- **배열** : 일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조

배열을 사용하면 하나의 선언을 통해서 둘 이상의 변수를 선언할 수 있다.

1차원 배열의 선언 : 별도의 선언 방법이 없으면 변수에 처음 값을 할당할 때 생성

( 연습 문제 )

상자들이 쌓여있는 방이 있다. 방이 오른쪽으로 90도 회전하여 상자들이 중력의 영향의 받아 낙하한다고 할 때, 낙차가 가장 큰 상자를 구하여 그 낙차를 리턴하는 프로그램을 작성하시오.

```python
'''
9
7 4 2 0 0 6 0 7 0
'''
N = int(input()) # 상자가 쌓여있는 가로 길이
arr = list(map(int, input().split()))

max_v = 0 # 가장 큰 낙차
for i in range(N-1): # i : 낙차를 구할 위치
    cnt = 0 # 오른쪽에 있는 더 낮은 높이의 개수
    for j in range(i+i, N):
        if arr[i] > arr[j]:
            cnt += 1
    if max_v < cnt: # 최대 낙차보다 크면
        max_v = cnt
print(max_v) # 7
```

---

## [ 버블정렬 ]

- 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식
- 정렬 과정
    - 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막 자리까지 이동한다.
    - 한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬된다.
    - 교환하며 자리를 이동하는 모습이 물 위에 올라오는 거품 모양과 같다고 하여 버블정렬
- 시간복잡도 : On²

- 배열을 활용한 버블 정렬

```python
N = 6
arr = [7, 2, 5, 3, 1, 4]

# for i : N-1 -> 정렬할 구간의 마지막 인덱스
for i in range(N-1, 0, -1):
    # for j : 0 -> i - 1 , j 비교할 두 원소 중 왼쪽 인덱스
    for j in range(i):
        if arr[j] > arr[j+1]: # 오름차수
            arr[j], arr[j+1] = arr[j+1], arr[j]
print(arr) # [1, 2, 3, 4, 5, 7]
```

---

## [ 카운팅 정렬 ]

- 항목들의 순서를 결정하기 위해 집합에 각 항목에 몇 개씩 있는지 세는 작업을 하여,
- 선형 시간에 정렬하는 효율적인 알고리즘
- 제한사항
    - 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능 : 각 항목의 발생 회수를 기록하기 위해, 정수 항목으로 인덱스 되는 카운트들의 배열을 사용하기 때문이다.
    - 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야한다.
- 시간 복잡도 : O(n+k) : n은 리스트 길이, k는 정수의 최대값

```python
[0,4,1,3,1,2,4,1]을 카운팅 정렬하는 과정 → 0 ~ 4의 정수로 구성

1단계)
- Data에서 각 항목들의 발생 회수를 세고, 정수 항목들로 직접 인덱스 되는 카운트 배열 counts에 저장한다.
DATA   0 4 1 3 1 2 4 1 -> 0:1개, 1:3개, 2:1개, 3:1개, 4:2개 -> COUNTS에 담기
COUNTS 0 0 0 0 0 ->
COUNTS 1 3 1 1 2 -> Data의 정수를 각 인덱스 자리에 저장(COUNTS[0] 1개, COUNTS[1] 3개, ...)

2단계)
- 정렬된 집합에서 각 항목의 앞에 위치할 항목의 개수를 반영하기 위해 counts의 원소를 조정한다
DATA   0 4 1 3 1 2 4 1
COUNTS 1 3 1 1 2 ->
COUNTS 1 4 5 6 8 -> 위의 COUNTS[0] = 1 / COUNTS[0] + COUNTS[1] = 4 / COUNTS[1] + COUNTS[2] = 5, ...

3단계)
- counts[1]을 감소시키고 Temp에 1을 삽입한다.
DATA    0 4 1 3 1 2 4 1
COUNTS [1->0] [4->3->2] [5->4] [6->5] [8->7->6]
TEMP   [0] [1] [1] [1] [2] [3] [4] [4]
- Temp 업데이터 완료하고 정렬 작업 종료한다.
```

```python
# 카운팅 정렬 과정
N = 6
K = 9 # 0~K
data = [7, 2, 4, 5, 2, 3] # 0~9, K=9
counts = [0] * (K+1)
temp = [0] * N
# counts 배열에 기록하기
for x in data:
    counts[x] += 1
# counts 누적합 구하기
for i in range(1, K+1):
    counts[i] = counts[i-1] + counts[i]
# data의 마지막 원소부터 정렬하기
for i in range(N-1, -1, -1): # N-1 -> 0번 인덱스
    counts[data[i]] -= 1 # 개수를 인덱스로 변환(남은 갯수 계산)
    temp[counts[data[i]]] = data[i]
print(*temp) # 2 2 3 4 5 7
```

---

## [ Baby-gin Game ]

- 설명
    - 0~9 사이의 숫자 카드에서 임의의 카드 6장을 뽑았을 때, 3장의 카드가 연속적인 번호를 갖는 경우를 run이라 하고, 3장의 카드가 동일한 번호를 갖는 경우를 triplet이라고 한다.
    - 그리고 6장의 카드가 run과 triplet로만 구성된 경우를 baby-gin이라 부른다.
    - 6자리의 숫자를 입력 받아 baby-gin 여부를 판단하는 프로그램 작성
- 입력 예
    - 667767은 두개의 triplet이므로 baby-gin (666, 777)
    - 054060은 한개의 run과 한개의 triplet이므로 역시 baby-gin (456, 000)

---

## [ 완전 검색 ]

- 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법
- 모든 경우의 수를 테스트한 후, 최종 해법을 도출한다
- 일반적으로 경우의 수가 상대적으로 작을 때 유용하다
- 모든 경우의 수를 생성하고 테스트하기 때문에 수행 속도는 느리지만(단점), 해답을 찾아내지 못할 확률이 작다(장점)
- Baby-gin Game - 고려할 수 있는 모든 경우의 수 생성하기
    - 6개의 숫자로 만들 수 있는 모든 숫자 나열 (중복 포함)
    - 예시) 입력으로 [2,3,5,7,7,7]을 받았을 경우, 모든 경우의 순열을 생성
    - 예시) [1,2,3]을 포함하는 모든 순열을 생성하는 함수
    
    ```python
    for i1 in range(1, 4):
    	for i2 in range(1, 4):
    		if i2 != i1:
    			for i3 in range(1, 4):
    				if i3 != i1 and i3 != i2:
    					print(i1, i2, i3)
    ```
    

---

## [ 탐욕 알고리즘 ( 그리디 )]

- 최적해를 구하는 데 사용되는 근시안적인 방법
- 여러 경우 중 하나를 선택해야 할 때 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달한다.
- 탐욕 알고리즘의 동작 과정
    1. 해 선택 - 최적 해를 구한 뒤, 부분 해 집합에 추가
    2. 실행 가능성 검사 - 문제의 제약 조건을 위반하지 않는지 검사
    3. 해 검사 - 문재의 해가 되는지 확인
- 예시) 거스름돈 줄이기
    - 어떻게 하면 손님에게 거스름돈으로 주는 지폐와 동전의 개수를 최소한으로 줄일까?
    - 해 선택 : 단위가 큰 동전으로만 거스름돈을 만들면 동전의 개수가 줄어든다
    
    ```python
    # 탐욕 알고리즘으로 Baby Gin 풀이
    
    num = 456789 # Bab Gin 확인할 6자리 수
    c = [0] * 12 # 6자리 수로부터 각 자리 수를 추출하여 개수를 누적할 리스트
    
    for i in range(6):
        c[num % 10] += 1
        num //= 10
    
    i = 0
    tri = run = 0
    while i < 10:
        if c[i] >= 3: # triplete 조사 후 데이터 삭제
            c[i] -= 3
            tri += 1
            continue
        # run 조사 후 데이터 삭제
        if c[i] >= 1 and c[i+1] >= 1 and c[i+2] >= 1:
            c[i] -= 1
            c[i+1] -= 1
            c[i+2] -= 1
            run += 1
            continue
        i += 1
    if run + tri == 2:
        print('Baby Gin')
    else:
        print('Lose')
    ```